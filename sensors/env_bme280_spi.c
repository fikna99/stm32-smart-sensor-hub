/**
 * @file env_bme280_spi.c
 * @brief BME280 environmental sensor driver (SPI2, HAL blocking).
 *
 * Notes:
 *  - SPI mode 0 (CPOL=0, CPHA=0)
 *  - NSS = software; CS is a GPIO (BME280_CS_Pin / BME280_CS_GPIO_Port)
 *  - Uses forced-mode measurement for simple sampling
 */

#include "env_bme280_spi.h"
#include "log.h"
#include "main.h"                 /* CubeMX-generated pin macros + hspi2 */
#include "stm32f4xx_hal.h"
#include <string.h>

/* SPI2 handle generated by CubeMX in main.c */
extern SPI_HandleTypeDef hspi2;

#define BME280_REG_ID           (0xD0U)
#define BME280_REG_RESET        (0xE0U)
#define BME280_REG_CTRL_HUM     (0xF2U)
#define BME280_REG_STATUS       (0xF3U)
#define BME280_REG_CTRL_MEAS    (0xF4U)
#define BME280_REG_CONFIG       (0xF5U)
#define BME280_REG_PRESS_MSB    (0xF7U)

#define BME280_RESET_CMD        (0xB6U)
#define BME280_DEVICE_ID        (0x60U)

#define BME280_STATUS_MEASURING (1U << 3)
#define BME280_STATUS_IM_UPDATE (1U << 0)

#define BME280_SPI_READ_MASK    (0x80U)

static SPI_HandleTypeDef *s_spi = NULL;

/* Calibration coeffs */
static uint16_t dig_T1;
static int16_t  dig_T2;
static int16_t  dig_T3;

static uint16_t dig_P1;
static int16_t  dig_P2;
static int16_t  dig_P3;
static int16_t  dig_P4;
static int16_t  dig_P5;
static int16_t  dig_P6;
static int16_t  dig_P7;
static int16_t  dig_P8;
static int16_t  dig_P9;

static uint8_t  dig_H1;
static int16_t  dig_H2;
static uint8_t  dig_H3;
static int16_t  dig_H4;
static int16_t  dig_H5;
static int8_t   dig_H6;

static int32_t  t_fine = 0;

/* Helpers */
static void prv_cs_low(void);
static void prv_cs_high(void);
static bool prv_write_reg(uint8_t reg, uint8_t value);
static bool prv_read_reg(uint8_t reg, uint8_t *value);
static bool prv_read_multi(uint8_t reg, uint8_t *buf, uint16_t len);
static bool prv_read_calibration(void);
static bool prv_wait_ready(uint32_t timeoutMs);
static void prv_compensate(int32_t adc_T, int32_t adc_P, int32_t adc_H, EnvData_t *out);

bool EnvBME280_Init(void)
{
    uint8_t id = 0U;

    s_spi = &hspi2;

    if (!prv_read_reg(BME280_REG_ID, &id))
    {
        LOG_ERROR("EnvBME280_Init: failed to read ID.");
        return false;
    }

    if (id != BME280_DEVICE_ID)
    {
        LOG_ERROR("EnvBME280_Init: unexpected ID=0x%02X expected=0x%02X",
                  (unsigned int)id, (unsigned int)BME280_DEVICE_ID);
        return false;
    }

    if (!prv_write_reg(BME280_REG_RESET, BME280_RESET_CMD))
    {
        LOG_ERROR("EnvBME280_Init: failed to write reset.");
        return false;
    }

    HAL_Delay(5U);

    if (!prv_wait_ready(200U))
    {
        LOG_WARN("EnvBME280_Init: sensor not ready after reset (continuing).");
    }

    if (!prv_read_calibration())
    {
        LOG_ERROR("EnvBME280_Init: calibration read failed.");
        return false;
    }

    /* Humidity oversampling x1 (must write before CTRL_MEAS). */
    if (!prv_write_reg(BME280_REG_CTRL_HUM, 0x01U))
    {
        LOG_ERROR("EnvBME280_Init: write CTRL_HUM failed.");
        return false;
    }

    /* CTRL_MEAS: osrs_t=x1 (001), osrs_p=x1 (001), mode=sleep (00) initially */
    if (!prv_write_reg(BME280_REG_CTRL_MEAS, 0x24U)) /* 0b00100100 */
    {
        LOG_ERROR("EnvBME280_Init: write CTRL_MEAS failed.");
        return false;
    }

    /* CONFIG: filter off, standby doesn't matter in forced mode. */
    (void)prv_write_reg(BME280_REG_CONFIG, 0x00U);

    LOG_INFO("EnvBME280_Init: OK (SPI2), ID=0x%02X", (unsigned int)id);
    return true;
}

bool EnvBME280_Read(EnvData_t *out)
{
    uint8_t buf[8];
    int32_t adc_P, adc_T, adc_H;

    if ((out == NULL) || (s_spi == NULL))
    {
        return false;
    }

    memset(buf, 0, sizeof(buf));

    /* Trigger forced mode: set mode bits to 01 */
    uint8_t ctrl_meas = 0U;
    if (!prv_read_reg(BME280_REG_CTRL_MEAS, &ctrl_meas))
    {
        LOG_ERROR("EnvBME280_Read: read CTRL_MEAS failed.");
        return false;
    }

    ctrl_meas = (uint8_t)((ctrl_meas & 0xFCU) | 0x01U);
    if (!prv_write_reg(BME280_REG_CTRL_MEAS, ctrl_meas))
    {
        LOG_ERROR("EnvBME280_Read: write CTRL_MEAS forced failed.");
        return false;
    }

    if (!prv_wait_ready(200U))
    {
        LOG_WARN("EnvBME280_Read: measurement timeout.");
        return false;
    }

    if (!prv_read_multi(BME280_REG_PRESS_MSB, buf, 8U))
    {
        LOG_ERROR("EnvBME280_Read: read data failed.");
        return false;
    }

    adc_P = (int32_t)((((uint32_t)buf[0]) << 12) | (((uint32_t)buf[1]) << 4) | (((uint32_t)buf[2]) >> 4));
    adc_T = (int32_t)((((uint32_t)buf[3]) << 12) | (((uint32_t)buf[4]) << 4) | (((uint32_t)buf[5]) >> 4));
    adc_H = (int32_t)((((uint32_t)buf[6]) << 8)  | ((uint32_t)buf[7]));

    prv_compensate(adc_T, adc_P, adc_H, out);
    out->timestampMs = Log_GetTimestampMs();

    LOG_DEBUG("EnvBME280_Read: T=%.2fC P=%.2fPa H=%.2f%%",
              (double)out->temperatureC,
              (double)out->pressurePa,
              (double)out->humidityRH);

    return true;
}

/* ------------------------------------------------------------------------- */
/* Low-level SPI helpers                                                     */
/* ------------------------------------------------------------------------- */

static void prv_cs_low(void)
{
    HAL_GPIO_WritePin(BME280_CS_GPIO_Port, BME280_CS_Pin, GPIO_PIN_RESET);
}

static void prv_cs_high(void)
{
    HAL_GPIO_WritePin(BME280_CS_GPIO_Port, BME280_CS_Pin, GPIO_PIN_SET);
}

static bool prv_write_reg(uint8_t reg, uint8_t value)
{
    uint8_t tx[2];
    HAL_StatusTypeDef st;

    if (s_spi == NULL)
    {
        return false;
    }

    tx[0] = (uint8_t)(reg & 0x7FU); /* write => MSB=0 */
    tx[1] = value;

    prv_cs_low();
    st = HAL_SPI_Transmit(s_spi, tx, 2U, 50U);
    prv_cs_high();

    if (st != HAL_OK)
    {
        LOG_WARN("BME280: SPI write reg=0x%02X fail st=%d", (unsigned int)reg, (int)st);
        return false;
    }

    return true;
}

static bool prv_read_reg(uint8_t reg, uint8_t *value)
{
    uint8_t tx;
    uint8_t rx;
    HAL_StatusTypeDef st;

    if ((s_spi == NULL) || (value == NULL))
    {
        return false;
    }

    tx = (uint8_t)(reg | BME280_SPI_READ_MASK);
    rx = 0U;

    prv_cs_low();
    st = HAL_SPI_Transmit(s_spi, &tx, 1U, 50U);
    if (st == HAL_OK)
    {
        st = HAL_SPI_Receive(s_spi, &rx, 1U, 50U);
    }
    prv_cs_high();

    if (st != HAL_OK)
    {
        LOG_WARN("BME280: SPI read reg=0x%02X fail st=%d", (unsigned int)reg, (int)st);
        return false;
    }

    *value = rx;
    return true;
}

static bool prv_read_multi(uint8_t reg, uint8_t *buf, uint16_t len)
{
    uint8_t tx;
    HAL_StatusTypeDef st;

    if ((s_spi == NULL) || (buf == NULL) || (len == 0U))
    {
        return false;
    }

    tx = (uint8_t)(reg | BME280_SPI_READ_MASK);

    prv_cs_low();
    st = HAL_SPI_Transmit(s_spi, &tx, 1U, 50U);
    if (st == HAL_OK)
    {
        st = HAL_SPI_Receive(s_spi, buf, len, 100U);
    }
    prv_cs_high();

    if (st != HAL_OK)
    {
        LOG_WARN("BME280: SPI read multi reg=0x%02X len=%u fail st=%d",
                 (unsigned int)reg, (unsigned int)len, (int)st);
        return false;
    }

    return true;
}

/* Wait until MEASURING and IM_UPDATE clear */
static bool prv_wait_ready(uint32_t timeoutMs)
{
    uint32_t start = Log_GetTimestampMs();
    uint8_t status = 0U;

    while ((Log_GetTimestampMs() - start) < timeoutMs)
    {
        if (!prv_read_reg(BME280_REG_STATUS, &status))
        {
            return false;
        }

        if ((status & (BME280_STATUS_MEASURING | BME280_STATUS_IM_UPDATE)) == 0U)
        {
            return true;
        }
    }

    return false;
}

static bool prv_read_calibration(void)
{
    uint8_t buf[26];
    uint8_t hbuf[7];

    if (!prv_read_multi(0x88U, buf, 26U))
    {
        return false;
    }

    dig_T1 = (uint16_t)((((uint16_t)buf[1]) << 8) | buf[0]);
    dig_T2 = (int16_t)((((int16_t)buf[3]) << 8) | buf[2]);
    dig_T3 = (int16_t)((((int16_t)buf[5]) << 8) | buf[4]);

    dig_P1 = (uint16_t)((((uint16_t)buf[7]) << 8) | buf[6]);
    dig_P2 = (int16_t)((((int16_t)buf[9]) << 8) | buf[8]);
    dig_P3 = (int16_t)((((int16_t)buf[11]) << 8) | buf[10]);
    dig_P4 = (int16_t)((((int16_t)buf[13]) << 8) | buf[12]);
    dig_P5 = (int16_t)((((int16_t)buf[15]) << 8) | buf[14]);
    dig_P6 = (int16_t)((((int16_t)buf[17]) << 8) | buf[16]);
    dig_P7 = (int16_t)((((int16_t)buf[19]) << 8) | buf[18]);
    dig_P8 = (int16_t)((((int16_t)buf[21]) << 8) | buf[20]);
    dig_P9 = (int16_t)((((int16_t)buf[23]) << 8) | buf[22]);

    if (!prv_read_reg(0xA1U, &dig_H1))
    {
        return false;
    }

    if (!prv_read_multi(0xE1U, hbuf, 7U))
    {
        return false;
    }

    dig_H2 = (int16_t)((((int16_t)hbuf[1]) << 8) | hbuf[0]);
    dig_H3 = hbuf[2];
    dig_H4 = (int16_t)(((int16_t)hbuf[3] << 4) | (hbuf[4] & 0x0FU));
    dig_H5 = (int16_t)(((int16_t)hbuf[5] << 4) | ((hbuf[4] >> 4) & 0x0FU));
    dig_H6 = (int8_t)hbuf[6];

    LOG_INFO("BME280: calibration loaded.");
    return true;
}

/* Compensation based on datasheet reference algorithms */
static void prv_compensate(int32_t adc_T, int32_t adc_P, int32_t adc_H, EnvData_t *out)
{
    int32_t var1, var2;
    float T;

    var1 = ((((adc_T >> 3) - ((int32_t)dig_T1 << 1))) * (int32_t)dig_T2) >> 11;
    var2 = (((((adc_T >> 4) - (int32_t)dig_T1) * ((adc_T >> 4) - (int32_t)dig_T1)) >> 12) *
            (int32_t)dig_T3) >> 14;

    t_fine = var1 + var2;
    T = ((float)(t_fine * 5 + 128) / 256.0f) / 100.0f;

    /* Pressure */
    int64_t var1p, var2p, p;
    float P;

    var1p = (int64_t)t_fine - 128000;
    var2p = var1p * var1p * (int64_t)dig_P6;
    var2p = var2p + ((var1p * (int64_t)dig_P5) << 17);
    var2p = var2p + (((int64_t)dig_P4) << 35);
    var1p = ((var1p * var1p * (int64_t)dig_P3) >> 8) + ((var1p * (int64_t)dig_P2) << 12);
    var1p = (((((int64_t)1) << 47) + var1p) * (int64_t)dig_P1) >> 33;

    if (var1p == 0)
    {
        P = 0.0f;
    }
    else
    {
        p = 1048576 - adc_P;
        p = (((p << 31) - var2p) * 3125) / var1p;
        var1p = ((int64_t)dig_P9 * (p >> 13) * (p >> 13)) >> 25;
        var2p = ((int64_t)dig_P8 * p) >> 19;
        p = ((p + var1p + var2p) >> 8) + (((int64_t)dig_P7) << 4);
        P = (float)p / 256.0f; /* Pa */
    }

    /* Humidity compensation (Bosch reference algorithm, formatting-safe) */
        int32_t v_x1_u32r;
        float H;

        v_x1_u32r = (t_fine - ((int32_t)76800));

        v_x1_u32r =
            (((((adc_H << 14) - (((int32_t)dig_H4) << 20) - (((int32_t)dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
             (((((((v_x1_u32r * ((int32_t)dig_H6)) >> 10) *
                  (((v_x1_u32r * ((int32_t)dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
                ((int32_t)2097152)) * ((int32_t)dig_H2) + ((int32_t)8192)) >> 14));

        v_x1_u32r =
            (v_x1_u32r -
             (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((int32_t)dig_H1)) >> 4));

        if (v_x1_u32r < 0)
        {
            v_x1_u32r = 0;
        }
        else if (v_x1_u32r > 419430400)
        {
            v_x1_u32r = 419430400;
        }

        H = (float)(v_x1_u32r >> 12) / 1024.0f;

    out->temperatureC = T;
    out->pressurePa   = P;
    out->humidityRH   = H;
}
